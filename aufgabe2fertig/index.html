<h1>Team FireWire</h1>
<br>
Uebung 1
<br>
<panel>Sprachaufnahme</panel>
<br>
<audio src="Sprache_FireWire.wav" controls>
  Sprachaufnahme
</audio>
<br>
<panel>Musikaufnahme</panel>
<br>
<audio src="Musik_FireWire.wav" controls>
  Musikaufnahme
</audio>
<br>
<panel>sine_hi01</panel>
<br>
<audio src="sine_hi01.wav" controls>
  sine_hi01
</audio>
<br>
<panel>sine_lo01</panel>
<br>
<audio src="sine_lo01.wav" controls>
  sine_lo01
</audio>
<br>
<p>Aufgabe 2.2 und 3.1</p>
<br>
<img src="schriftlich.jpg" width="400" height="800">
<br>
<p>Aufgabe 2.3</p>
    
<p>Das Verfahren zur Vermeidung von Aliasing, auf Soundkarten bezeichnet man als „idealer Tiefpass“. 
Dieses Verfahren beschreibt eine Funktion, die durch eine Grenzfrequenz B einen Filter besitzt, die nur Frequenzen hindurchlässt die unter der Grenzfrequenz liegen. Alles was größer ist wird blockiert.
Diesen „idealen Tiefpass“ gibt es allerdings nur in der Theorie. In der Praxis kann der „ideale Tiefpass“ auf Grund von unendlich langen Impulsantworten nicht erreicht werden.
Der „reale Tiefpass“ kann annähernd an den „idealen Tiefpass“ mit der Formel: H(f) = rect(f/2B)
berechnet werden.
B – Grenzfrequenz	f – Frequenz	rect - Rechtecksfunktion
</p>
<br>
<p>Aufgabe 2.4</p>
<br>
<panel>downsampled high</panel>
<object data="out_file_downsampled_sine_hi01.txt" type="text/txt" width="200" height="100">
 </object>
<audio src="out_file_downsampled_sine_hi01.wav" controls>
</audio>
<br>
<panel>downsampled low</panel>
<object data="out_file_downsampled_sine_lo01.txt" type="text/txt">
 </object>
<audio src="out_file_downsampled_sine_lo01.wav" controls>
</audio>
<p>Aufgabe 3.3</p>
<br>
<panel>Sprache 10Bit Verlust</panel>
<audio src="out_file_Sprache_FireWire10rb.wav" controls></audio>

<img src="Plot FireWire_Sprache10rb.PNG">
<br>
<panel>Sprache 12Bit Verlust</panel>
<audio src="out_file_Sprache_FireWire12rb.wav" controls></audio>

<img src="Plot FireWire_Sprache12rb.PNG">
<br>
<p>Aufgabe 3.4</p>
<panel>sine_hi01 Quantisiert</panel>
<br>
<audio src="out_file_sine_hi01_q.wav" controls>
</audio>
<br>
<panel>sine_lo01 Quantisiert</panel>
<br>
<audio src="out_file_sine_lo01_q.wav" controls>
</audio>
<br>
Uebung 2 bmp_io
<br>
<label>Detail Foto</label>
<br>
<img src="a2_detail1.bmp">
<br>
<label>Flächen Foto</label>
<br>
<img src="a2_fläche1.bmp">

<p>Aufgabe 2.1</p>
<br>
<object data="out_grating_H3.txt" type="text/txt" width="200" height="100">
 </object>
<img src="out_grating_H3.bmp">
<br>
<object data="out_grating_V3.txt" type="text/txt" width="200" height="100">
 </object>
<img src="out_grating_V3.bmp">
<br>
<p>Aufgabe 2.2</p>
<p>Aufgabe 2.3</p>
<br>
<p>
brightness = Math.sqrt{0.299*Math.pow(r,2) + 0.587*Math.pow(g,2) + 0.114*(Math.pow(b,2))}
<br>
    
Die drei Koeffizienten 0.299, 0.587 und 0.114 gewichten die drei Farbkomponenten hinsichtlich der menschlichen Helligkeitswahrnehmung. Denn bei gleichem Farbwert wird Blau vom Menschen dunkler wahrgenommen als Rot und Rot dunkler als Grün. Die Summe der drei Koeffizienten ergibt 1, entsprechend hat die Funktion den gleichen Wertebereich wie die drei Farbkomponenten.</p>
<br>
<img src="out_a2_detail_grey.bmp">
<br>
<img src="out_a2_fläche_grey.bmp">
<br>
<p>Aufgabe 2.4</p>
<br>
<p>Das Aliasing entsteht durch eine Bewegung, die schneller ist als die aufnehmbaren Bilder pro Sekunde des Aufnahmegeräts. Dadurch entsteht die Illusion, dass das Objekt sich gar nicht oder Rückwärts bewegt.  </p>
<br>
<img src="out_grating_H3_downsampledHori.bmp">
<br>
<img src="out_grating_V3_downsampledVert.bmp">
<p>Aufgabe 2.5</p>
<br>
<img src="out_a2_detail_downsampled.bmp">
<br>
<img src="out_a2_fläche_downsampled.bmp">
<p>Schon beim ersten Downsampling mit Modulo 2, erkennt man die Verschlechterung im Bild</p>
<p>Aufgabe 3.2</p>
<p>Aufgabe 3.3</p>
Uebung 3 (leer)